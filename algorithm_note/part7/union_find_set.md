这一节来看并查集。并查集是一种特殊的树，当我们只关注元素是否关联，而不关注关联的结构时，我们就可以使用并查集。比如人际关系中，我们只关注是不是亲戚，而不关注是叔叔还是表哥。

并查集用一个数组实现,`father[i]`表示元素`i`的父结点，以此表示元素的归属集合。如果`father[i]==i`则说明元素`i`是该集合的根结点，一个集合只有一个根结点，所以将其作为所属集合的标识。每一个集合都是一个多叉树。
```c++
int father[N];
// 初始化
void init(){
    for(int i=0;i<N;i++)
        father[i]=i;
}
```

并查集有两个操作，查找（find）和合并（union）。

查找操作，同一个集合只有一个根结点，所以就是给定结点寻找其根结点的操作。因为不关注结构，所以可以采用路径压缩，让集合中的每个结点都作为根结点的子结点，加快查找速度。
```c++
int find(int x){
    //路径压缩
    return x==father[x]?x:father[x]=find(father[x]);
}
```

合并操作，先判断两个结点是否属于同一个集合，如果不是，就把其中一个集合的根结点的父亲指向另一个集合的根结点。
```c++
void myunion(int x, int y){
    int fx=find(x);
    int fy=find(y);
    if(fx!=fy){
        father[fx]=fy;
    }
}
```

练习：
1. leetcode 128 最长连续序列：第一种思路，对所有元素`i`寻找以他为起始的最长连续序列，寻找后序`i+1`，`i+2`等元素可以通过将所有元素装到哈希表里面来提速，这样时间复杂度为$O(n^2)$。仔细思考后可以发现，如果存在元素`i-1`，那么以i-1开始的最长连续序列必然比以`i`为开始的最长连续序列长，所以没必要从开`i`开始算，所以相当于只需要遍历每个序列的最左元素即可，每个元素只被访问1次，时间复杂度为$O(n)$.第二种思路采用并查集，每个元素的父结点为以它作为开始的最长序列的最右元素。

2. leetcode 200 岛屿的数量：这题和leetcode130被围绕的区域很像。一种简单的思路就是用bfs或者dfs去遍历，发现几个连通分量就有几个岛，时间复杂度为O(n)。也可以使用并查集