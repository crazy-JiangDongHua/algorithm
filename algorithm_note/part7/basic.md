本节介绍树与二叉树的基本定义。

### 1. 树的定义

树由**结点**和**边**构成，最上层的结点称为**根结点**。根结点通过边到达**子结点**，从而形成**子树**。

其他一些比较重要的概念：
1. 树可以没有结点，此时为空树。
2. 树的 **层次(layer)** 从根结点算起，即根结点为第一层。
3. 结点的子结点数目称为**度(degree)**，树中结点数最大的度称为树的度。
4. 对于$n$个结点的树，有且只有$n-1$条边。树是最大连通图，最小无环图，再多1条边就有环路。
5. 结点的**深度**是从根结点到结点的路径长度，结点的**高度**是以该结点为根结点的子树中，最底层的叶结点到该结点的路径的长度。树的深度指树中结点的最大深度，树的高度指树中结点的最大高度，因此树的深度和高度相等。
6. 多棵树组合在一起称为**森林**。
7. 孩子结点，父亲结点，祖先结点，兄弟结点。

### 2. 二叉树的定义
递归定义：
1. 二叉树没有根结点，是一棵空树。
2. 二叉树由根结点，左子树和右子树组成，且左子树和右子树都是二叉树。

普通定义：最大度为2，且明确定义了孩子左右次序的树。

满二叉树：每层结点个数达到了该层能达到的最大结点数的二叉树。

完全二叉树：只有最后一层的节点个数没有达到该层能达到的最大结点数的二叉树。完全二叉树的叶子结点一定比2度结点多1个，所以叶结点总是占结点数的一半（奇数个结点就多一个），完全二叉树最多只有一个1度结点，其余非叶结点都是2度结点。

因为任意一棵树都可以表示为二叉树———将第一个孩子结点作为左孩子，第一个右边的兄弟结点作为右孩子，且二叉树的应用更多，所以我们主要研究二叉树。

### 3. 二叉树的存储
二叉树通常通过二叉链表存储：
```c++
struct node{
    int data;
    node *lc, *rc;
    // 为了方便还可以加一个father指针
    node():data(-1),lc(nullptr),rc(nullptr){}
    node(int val):data(val),lc(nullptr),rc(nullptr){}
}
```
而对于完全二叉树，我们可以舍弃左右子结点指针，使用数组来存储。令根结点编号为1，对于编号为$x$的结点，他的左孩子结点编号为$2x$，右孩子结点编号为$2x+1$。对于高度为$h$的完全二叉树，定义规模为$2^h+1$的数组存储即可。数组中元素的次序就是该树的层次遍历次序。
```c++
int h;//height
int n;//node num
int tree[2eh+1];

#define root (1);
#define lc(x) (2*x);
#define rc(x) (2*x+1);
#define father(x) (x/2);
#define isLeaf(x) (2x>n);
#define isNull(x) (x>n);
```

### 4. 二叉树的操作
1. 查找
```c++
node* search(node* root, int x){
    if(root==nullptr)return root;
    if(root->data==x)return root;
    search(root->lc);
    search(root->rc);
}
```
2. 插入
二叉树的插入我们可以只关注作为结点左孩子插入，作为结点右孩子插入。根据元素顺序插入我们放在二叉搜索树里面去讲。
```c++
void insertAsLc(node* father, int val){
    father->lc = new node(val);
}
```
3. 建树
机试如果需要自己建立数据，那一般给的都是给出了结点的编号(1,2,3,...,N)，这种情况下，可以直接开`node`数组，也可以开`node*`数组，然后动态创建结点。但是一定要开数组方便索引结点。


练习：
1. leetcode 111 二叉树的最小深度：可以用递归，递归分枝和求结点高度还有点不一样，重点在于如果一个结点有一个孩子的时候，他的最小深度不能从空孩子那边算成1。也可以使用层次遍历，遍历到第一个叶结点的时候就得到了最小深度。
2. leetcode 104 二叉树的最大深度：简单递归
3. leetcode 112 路径总和：明确题意是到达叶结点的路径，所以一直递归到叶结点.也可以用层序遍历，遍历到叶结点如果当前和与目标相等，就返回true。
4. leetcode 113 路径总和2：和上一题思路一样，保存一下就行
5. 124 二叉树中的最大路径和：此题可以看成前继有两个方向的最大连续子段和，每次可以取左右两条路径和根结点的和，但是向上继续传递只能取一个方向。
6. 129 求根节点到叶节点数字之和:简单递归。