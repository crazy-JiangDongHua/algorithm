平衡二叉搜索树哪里都好，增删改查都只需要$O(\log n)$的时间，唯一不好的就是太复杂自己写不出来hhhh。如果我们的目标简化一下，每次只需要找到数据中最大或最小的元素，有没有更简单但是同样高效的数据结构可以用呢？当然有啦，那就是堆，又名优先级队列。

堆是一个完全二叉树，树中每一个顶点都不小于其左右孩子的值（大顶堆，小顶堆反之）。完全二叉树可以用数组表示，并可以在$O(1)$的时间内找到父亲，左右孩子（详见[树与二叉树的基础知识](./basic.md)）。

堆主要有四个操作，建堆（init），增加（insert），删除（delete），取最大元素（top）。

建堆采用自底向上的下溢，从下往上遍历每一个元素，快速定位该元素在以其为根结点的子树中的位置（下溢），所需的时间复杂度为$O(n)$。也可以采用自上而下的上溢，时间复杂度为$O(n\log n)$
```c++
int heap[N];
int n;//实际size
void down(int i){
    int j=2*i+1;//lc
    while(j<n){
        if(j+1<n && heap[j+1]>heap[j])
            j=j+1;
        if(heap[j]>heap[i]){
            swap(heap[i],heap[j]);
            i=j;j=2*i;
        }else{
            break;
        }
    }
}
void init(){
    //原地操作
    for(int i=n/2;i>=0;i++){//完全二叉树，非叶结点有floor(n/2)个
        down(i, n);
    }
}
```

删除堆顶元素，先把堆顶元素与最后一个元素交换，然后`size-1`，逻辑上就删除了最后一个元素，然后堆顶元素还需要下溢，时间复杂度为$O(\log n)$
```c++
void deleteTop(){
    heap[0]=heap[n--];
    down(0,n);
}
```

插入元素，先把元素放在堆的尾部，然后上溢调整。
```c++
void up(int i){
    while(i>0){
        j=(i-1)/2;
        if(heap[j]<heap[i]){
            swap(heap[i],heap[j]);
            i=j;
        }else{
            break;
        }
    }
}
void insert(int x){
    heap[n++]=x;
    up(i);
}
```

返回堆顶元素，就是返回数组第一个元素就可以了。
```c++
int top(){
    //最好加一个判空条件
    return heap[0];
}
```


有了上述的堆介绍，想要用堆做排序就太简单啦，直接放代码
```c++
void heapSort(){
    init();
    while(n--){
        swap(heap[0], heap[n]);//将堆顶元素与最后一个元素交换，同时也是最大元素放到最后
        down(0);//相当于堆顶元素已经删除，下溢调整
    }
}
```

练习：
1. leetcode 218 天际线问题：很有意思的一道题，首先要看到所有的天际线都是建筑的左右边界。然后需要定义的是边界高度的定义，每个建筑物包含了其左闭右开区间的所有边界，对于每个边界，其高度定义为包含其建筑物中的最大高度，如果没有就是0。知道所有边界及其高度以后，从左至右遍历就可以知道天际线。寻找边界对应高度可以使用暴力法，这样时间复杂度为$O(n^2)$，可以用堆加速，时间复杂度变为$O(n\log n)$.
2. leetcode 239 滑动窗口最大值:第一种思路是使用优先级队列，只要当前的堆顶元素的编号还在窗口内，那么堆顶元素就是当前窗口的最大值。否则一直pop到堆顶元素在窗口内。最坏情况下，元素递增排列，堆的最大规模为`n`，所以时间复杂度为$O(n\log n)$。第二种思路是采用单调队列。窗口中如果存在`i<j`，`arr[i]<=arr[j]`那么在`i`永远不可能成为窗口的最大值。所以我们就可以维护一个窗口内的单调递减序列。时间复杂度为$O(n)$，空间复杂度$O(k)$。