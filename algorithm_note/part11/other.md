这一节来做一些，不是很难，但是需要注意细节的题目。这类题目不考具体的算法，主要考察代码的熟练度。

练习：
1. leetcode 7 整数反转：思路是常规的，就是对x不断求模10取最后一位，然后加到sum里面。这道题的难点在于数据很强，要求不能用long long，如果反转后的数超过int范围，就返回0。假设`x>0`，超过int范围可以表示为：`sum*10+x%10>INT_MAX=(INT_MAX/10)*10+INT_MAX%10`。如果`sum>INT_MAX/10`或者`sum==INT_MAX/10`但是`x%10>INT_MAX%10=7`不等式成立。我们考虑第二种情况，即`sum==INT_MAX/10`，这说明`x`和`INT_MAX`位数一样，因为`INT_MAX=2147483647`，所以`x`的第一位数字一定小于等于2，而`INT_MAX%10=7`，所以`x%10<INT_MAX%10=7`一定成立。所以只有当`sum>INT_MAX/10`，反转后的x会超出范围。`x<0`时的分析同理。
2. leetcode 9 回文数：为了避免使用字符串，可以将数字反转，然后比较反转后的数值和原数值是否相等。因为本题数据范围很广，直接反转会超过int的范围，有两种方案：1.使用long long存储反转后的数字2.反转一半数字比较。
3. leetcode 57 插入区间：简单模拟，看代码就懂。
4. leetcode 56 合并区间：先排序，然后简单模拟。
5. leetcode 76 最小覆盖子串：使用双指针，滑动窗口，尾指针不断往后扫描，直到一个窗口包含了t所有的字符，然后头指针收缩，直到不再包含t所有字符，最后记录所有可能情况中最小的。
6. leetcode 43 字符串乘法：转为大数乘法
7. leetcode 438 找到字符串中所有字母异位词：使用hash表存储p的字符出现频率，在s使用滑动窗口，用differ表示滑动窗口区域和p的频率不相同字符的个数，所以当differ==0时两者互为字母异位词
8. leetcode 30 串联所有单词的子串：这题的思路和上一题非常相似，上题比较的是字符频率，这题改成字符串频率就可以。另外一个问题是如何划分，我们可以从s的[0,n]这n个位置分别开始，其中n是word的长度，然后划分s为子串，维护滑动窗口并比较。
9. leetcode 118 杨辉三角：简单模拟
10. leetcode 119 杨辉三角2：简单模拟
11. leetcode 54 螺旋矩阵：按层模拟，有一定难度，很难做到10分钟bug free。
12. leetcode 59 螺旋矩阵2：和leetcode54一样的思路，按层模拟即可。
13. leetcode 6 z字型变化：模拟，先把字符串按照z型展开，存到矩阵中，然后在合并，字符串变换周期为2*num-2
14. leetcode 29 两数相除：这道题非常有挑战，感觉如果面试就直接g。题目施加了非常多的限制，只能用有符号32位整数，不能用乘法，除法和求模运算。首先可以想到的是，可以用减法来模拟乘法。为了统一情况，我们可以把被除数和除数都放到负数域或正数域来做。因为INT_MIN转到正数域越界，所以转到负数域来做。现在被除数和除数都是负数，那么结果一定大于等于0。可表示的范围是0到INT_MAX，但是这里存在两种情况会超出这个表示范围：1.被除数是INT_MIN，除数是1；2.被除数是INT_MIN，除数是-1。排除掉这两个特殊情况以后，就可以开始做了，但是发现直接减会超时，所以我们用二分搜索来加速，设变化到负数域的被除数为x，除数为y，结果为z，那么有z*y>=x>(z+1)*y。那么我们可以在[0,INT_MAX]这个范围上搜索最大的满足z*y>=x的z。但是我们不能用乘法，只能自己实现了，用快速幂的思想，把乘法改成加法就是快速乘了。时间复杂度为$O(\log C \times \log C)$，其中C是32为有符号整数的范围。
15. leetcode 68 文本左右对齐：中等难度的模拟。
16. leetcode 149 直线上最多的点数：以点为中心枚举所有可能的边。有一个技巧需要注意，用斜率表示边时，不能直接用double，因为小数算不准，所以我们用分数表示斜率。然后需要对分数hash，因为up的范围是[0,20000]，down的范围是[-20000,20000]，所以我们可以先给down+20000，然后吧up和down看成是两位的40001进制数。