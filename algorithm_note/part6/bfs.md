广度优先搜索

1. 模板

```c++
void bfs(int s)
{
    queue<int> q;
    q.push(s);
    while(!q.empty())
    {
        //取出队首元素
        //访问队首元素
        //将队首元素出队
        //将该元素中下层元素未曾入队的节点全部入队，并设置为已经入队
    }
}
```

练习：
1. leetcode 127 单词接龙：当所有边对应的距离都为单位长度时，bfs可以计算节点之间最短距离。每个单词可以看成一个节点，满足条件就有一条边，因此可以建图，然后bfs。假设单词数$O(n)$，每个单词长度为$\theta (n)$，那么所有单词之间相互比较查看是否满足规则时间太慢，需要$O(n^2)$的时间。根据规则的特殊性，我们可以给每个单词增加$C$个相连的虚拟节点，将建图的时间缩短为$O(C\times N)$。bfs的时间复杂度等价于节点数量，即$O(n^2)$。同时可以从两端开始bfs，从常系数上减少时间复杂度。
2. leetcode 126 单词接龙2：寻找所有路径，所以需要记录每一个节点的所有的父节点，然后使用dfs取遍历路径。仍然可以使用上一题的技巧，优化建立图，但是还不知道怎么用两端bfs。也可以边搜索边建图，就是遍历每一位字符，有26个字母，时间复杂度是$O(C \times N \times 26)$，但是空间上不用保存图了，节省了$O(C \times N)$的空间。
3. leetcode 130 被围绕的矩阵：遍历所有四边上的`‘O’`，和他们相连的`'O'`（dfs或者bfs）不会被包围，可以利用不会出现的字符就地的表示该位置是否被访问，节省空间和时间。

tips:
1. 对于只需要求最短路径长度时，可以在主循环中添加一个for循环，来实现一层一层访问，这样可以节省存储每个节点层次的空间
```c++
queue<int> q;
int level=0;
while(!q.empty()){
    for(int i=0,n=q.size();i<n;i++){
        int f=q.front();q.pop()
        // 遍历下一层节点并处理
    }
    level++;
}
```