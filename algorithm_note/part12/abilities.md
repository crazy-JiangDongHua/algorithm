## 1. 沟通能力和学习能力
1. 沟通能力：主要体现在介绍自己的项目经验和解题思路上，强调知之为知之，不知为不知，不要不懂装懂。面试外企还要额外准备英文听力。
2. 学习能力：有两种提问方式，一种是询问最近的学习计划，一种是给一个新概念，考察应聘者能否在短时间内理解并解决相关问题。
3. 善于学习、沟通的人也善于提问：面试官提出一个新概念，应聘者没有听说过，应该在自己的理解基础上向面试官提问，表现自己的学习能力和对学习的积极性。

## 2. 知识迁移能力
知识迁移能力其实就是举一反三的能力，强调把经典问题的思路迁移到新问题上。

面试题：
1. offer53-1 数字在排序数组中出现的次数：用二分查找找到第一个出现的位置和最后一个出现的位置，时间复杂度为$O(\log n)$
2. offer53-2 0~n-1中缺失的数字：该问题可以转化为寻找排序数组中第一个值和下标不相等的元素，利用二分查找，时间复杂度为$O(\log n)$
3. offer53-3 数组中数值和下标相等的元素：同样采用二分查找，如果数值m大于下标i，那么其后元素数值都会大于下标，所以只需搜索左半区；如果数值m小于下标i，那么其前元素值都会小于下标，所以只需搜索右半区；如果想等就正好找到。
4. offer54 二叉搜索树的第k大节点：中序遍历，需要注意的是，原书的第k大和leetcode的第k大语意不同。
5. offer55-1 二叉树的深度：简单递归。
6. offer55-2 平衡二叉树：简单递归。利用返回深度为-1表示不是平衡，省去一个参数。
7. offer56-1 数组中只出现一次的两个数字：如果只有一个数字只出现一次，那么直接整个数组做异或就可以了。现在有两个数字，如果我们能把数组分为两组，每组都只有一个只出现一次的数字，就可以用异或处理。那怎么分呢，我们首先还是把所有数都做异或，因为有两个数不同，所以结果肯定不为零，我们找结果二进制中第一个为1的位，然后用这一位是0还是1为标准把数组分为两组，然后再分别做异或就可以了。
8. offer56-2 数组中唯一只出现一次的数字：统计每个bit位1出现的次数，如果不能被3整除，那说明唯一出现一次的数字这一位为1。
9. offer57-1 和为s的数字：对撞指针。
10. offer57-2 和为s的连续正数序列：滑窗指针,左指针小于$\lceil target/2 \rceil$
11. offer58-1 翻转字符串：先整个翻转字符串，再翻转每一个单词。
12. offer58-2 左旋转字符串：继承上一题的思路，可以看成是翻转有两个字符的字符串。
13. offer59-1 滑动窗口的最大值：相当于构建一个能在$O(1)$时间内得到最小值的队列。维护一个双头队列。入队时如果插入元素小于等于队尾元素，则直接入队；如果插入元素大于队尾元素，则将队尾元素从队尾出队。出队时，如果等于双头队列对头元素则一起出，否则不出。
14. offer59-2 队列的最大值：与前一题相同；

## 3. 抽象建模能力
面试官喜欢从日常生活中抽取提炼出问题，考察应聘者的抽象建模能力。

面试题：
1. offer60 n个骰子的点数：首先可以想到暴力枚举所有可能，可以通过递归实现，即`f(n)`可以通过`f(n-1)`处理得来，但是中间存在非常多的重叠子问题，因此想到用备忘录方法，通过滚动数组，使得空间复杂度只是翻倍，时间复杂度大大降低。
2. offer61 扑克牌中的顺子：把大小王看成零，然后对数组排序，统计0的个数和数组中间数字的间隔数，如果想等就刚好可以变成顺子。另外，如果有非零数字重复出现，就不可能时顺子。
3. offer62 圆圈中最后剩下的数字：最直接的想法就是用环形链表模拟，时间复杂度为$O(mn)$，空间复杂度为$O(n)$，另外可以通过数学解法省去模拟的过程，时间复杂度为$O(n)$，空间复杂度为$O(1)$。
4. offer63 股票的最大利润：简单贪心.

## 4. 发散思维能力
面试题：
1. offer64 求1+2+...+n：可以把计算放到构造函数里面，然后创建数组来隐式循环调用构造函数。还有一种思路是利用非运算和函数指针，不能使用递归的原因在于不能用if，但是对于特殊的输入，我们可以用连续两个非来作为判断条件，`!!0==0`，`!!n==1`，所以可以把递归基函数和递归状态转移函数分别放在数组的0，1位置，从而解决不能用if的问题。
    同时学到了一点c++知识：
    1. private static 和 public static 都是静态成员，非常量静态成员，在类加载时就声明，必须在类外初始化；常量静态成员可以在类内初始化。
    2. private static 是私有的，不能在外部访问，只能通过公有的静态方法或非静态方法调用，这样可以防止对变量的修改；public static 是公有的，还可以来类外通过类名访问。
    3. static 成员函数只能访问static成员变量，非static成员函数可以访问static成员变量。
    4. 非 static成员函数会隐式添加this指针到参数列表，而每个类对象都会隐式保存自己的拷贝，即this指针，所以非 static成员函数必须由类对象或类指针调用
    5. 因此非 static成员函数的函数指针形式与普通函数指针不同，格式为`返回值 (类名::* 指针名)(参数列表)`，赋值：`指针类型名 指针名=&类名::成员函数名`，调用：`(类对象.*指针名)(参数列表);(类指针->*指针名)(参数列表)`。同理，非 static成员变量的指针形式为`类型 类名::* 指针名`，赋值和调用同理。
        由上也不难看出，非static成员函数指针不可作为sort的参数。
    6. static成员变量指针和成员函数指针与普通函数相同。

2. offer65 不用加减乘除做加法：用异或产生没有进位的加法结果，用与和移位产生进位结果，然后重复相加知道进位为0。在 C++ 的实现中，当我们赋给带符号类型一个超出它表示范围的值时，结果是 undefined；而当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模的余数。因此，我们可以使用无符号类型来防止溢出。
3. offer66 构建乘积数组：计算前缀和后缀的乘积数组，实际上只需要逻辑上维护这两个数组就可以了。
