本章介绍了面试所需要的基本知识。主要包括两个方面：编程语言和基础专业课（例如操作系统）

## 1. 编程语言
校招编程语言精通一门就好，c++或者java问的比较多，根据岗位需要来。有两种形式：
    * 直接问语法问题，这种学完以后刷八股文就行
    * 给一段代码问运运行情况：编译错误 or 编译成功，运行失败 or 运行成功
经典面试题：实现一个单例模型。
解法1:只适用于单线程
```c++
public class Singleton1{
    private Singleton1(){}
    private static Singleton1 instance=nullptr;
    public static Singleton1& Instance{
        if(instance==nullptr){
            instance=new Singleton1();
        }
        return instance;
    }
};
```
解法2:适合多线程，但是效率很低
```c++
public class Singleton2{
    private Singleton1(){}
    private static Singleton1 instance=nullptr;
    public static Singleton1& Instance{
        lock(){ //加一个同步锁
            if(instance==nullptr){
                instance=new Singleton1();
            }
        }
        return instance;
    }
}
```
解法3:适合多线程，效率稍微高点
```c++
public class Singleton2{
    private Singleton1(){}
    private static Singleton1 instance=nullptr;
    public static Singleton1& Instance{
        if(instance==nullptr){// 防止每次访问都要加锁，如果已经有了就没必要加锁
            lock(){ //加一个同步锁
                if(instance==nullptr){
                    instance=new Singleton1();
                }
            }
        }
        return instance;
    }
}
```

## 2. 数据结构
数据结构是技术面试的重点，大多数面试题都是围绕着数组、字符串、链表、树、栈以及队列展开。

### 2.1 数组
1. offer3 数组中重复的数字：可以直接排序，也可以使用哈希表。时间复杂度为$O(n)$，空间复杂度为$O(1)$的算法是，直接使用数组本身做哈希，从头到尾扫描数组，扫描到下标为i的数字的时候，首先比较这个数m是不是i。是就扫描下一个，不是就把它和arr[m]比较，相等就是重复数字，不想等就交换，然后重复这个过程只到想等或者重复。
2. 不修改数组找出重复的数字：可以看作是上一题的变体，不能修改数组，最直接的思想就是用hash表。但是也可以用二分的方法，因为范围是1～n，但是有n+1个数，所以一定有重复，可以统计把1～n的范围二分，如果属于1～n/2的范围的数的个数多余n/2，那重复的数一定出在1～n/2的范围，重复只到只剩一个数。这样时间复杂度为$O(n\log n)$，空间复杂度为$O(1)$。看面试官要求时间复杂度优先还是空间复杂度优先。PS：使用快速排序的递归空间复杂度最好为$O(\logn)$, 该题没有leetcode原题，直接放在上一题的题解下面
3. offer4 二维数组中的查找：从左下角或者右上角开始搜索，每次缩小一行或者一列。另外一种变体是再加一个约束条件，数组的前一行的所有数一定比后面一行的数都要小，这种就可以先对第一列二分，然后在对选定行二分。

### 2.2 字符串
1. offer5 替换空格：首先要清楚要求是原地替换，还是新建字符串替换。原地替换，就要保证原字符串足够长，然后先算替换后长度，然后从后往前填词，时间复杂度为$O(n)$。新建字符串，那就从其那往后填就行。

### 2.3 链表
1. offer6 从尾到头打印链表：如果不允许修改链表，就用栈或者递归。允许就反转链表。

### 2.4 树
1. offer7 重建二叉树：给定前序和中序遍历结果，重建二叉树，经典递归。
2. offer8 二叉树的下一个结点：就是之前提到的succ函数，要么是右子树的最左结点，要么是第一个把该结点包含在左子树的结点。**PS：这题leetcode没有收录。**

### 2.5 栈和队列
1. offer9 用两个栈实现队列：push全部进栈1，pop时，只要栈2没空，就弹出栈2顶端元素，否则把栈1元素先压入栈2再弹出。
相关题目：使用两个队列实现一个栈，元素插入queue1，每次弹出时，先把除最后入queue1的元素外的所有元素，依次弹出queue1再压入queue2，然后弹出最后一个元素。其实也不一定需要queue2，压入queue1也是可以的。所以只需要一个队列就能实现了。还有一种做法，是每次插入元素时，把之前队列里面的元素依次出队再入队，维护队列内元素始终是堆的次序。这样中方法本质是一样的，区别在于前一种把移动操作放在pop上，后一种把移动操作放在push上。

## 3 算法和数据操作
1. 要随时能写二分查找，归并排序和快速排序
2. 会回溯，一般用到递归，要会用栈模拟递归
3. 动态规划，如果面试官提示说某个子问题可能会有特殊情况，那就可能是贪心
4. 位运算：与、或、异或、左移和右移

### 3.1 递归和循环
递归代码简洁，但是效率不如循环，更有可能出现重叠子问题。可以用递归思想分析，自底向上实现。
1. offer10-1 斐波那契数列：动态规划。矩阵快速幂更快一般不考
2. offer10-2 青蛙跳台阶问题：斐波那契数列变种。
相关题目，如果青蛙跳台问题中，每个青瓜可以跳1级，2级，...，n级别。那么跳上一个n级的台阶总共有$2^(n-1)$种方法。还提到一个用$2\times 1$的小矩形覆盖8个$2\times 1$的矩形，这也是斐波那契数的变形。

### 3.2 查找和排序
查找主要就几种：顺序查找，二分查找，哈希表查找和二叉排序树查找。如果二分查找都写不出来那真的凉凉。
排序主要就是：插入排序、冒泡排序、归并排序、快速排序等等。对于小范围整数数据，可以用计数排序。

1. offer11 旋转数组的最小数字：可以利用旋转数组的特性，先选出中间元素，如果中间元素大于最右边元素，说明中间元素位于第一个递增序列，最小元素在后面，直接把左边界移动到中间+1的位置。反之，如果中间元素小于最右边元素，中间元素位于第二个递增序列，把右边界移动到中间，如果相等，此时无法判断，但是我们可以出去最右边元素，因为有一个中间元素和它相等，这就相当于爆搜了。最后收敛到只剩下一个元素的时候，就是最小值。

### 3.3 回溯法
1. offer12 矩阵中的路径：简单回溯。
2. offer13 机器人的运动范围：几乎和上题一摸一样。

### 3.4 动态规划和贪婪算法
1. offer14 减绳子：一种是dp，`dp[i]`表示长度为i的绳子剪成若干段（可以不减）之后最大乘积，递推式为`dp[i]=max(dp[j],dp[i-j]), 1<=j<=i/2`。对于长度为2的绳子，减一刀最大乘积为1，但是作为子问题时，dp[2]=2。长度为3的绳子同样有这个问题。该问题也可以用贪心的思想，只要长度大于5，那就每次减3，如果还剩4，那就分成两个2。
    leetcode就这个问题给了两个题，只有测试数据的规模不一样大。

### 3.5 位运算
1. offer15 二进制中1的个数：常规思路是不断做x&1，然后右移x，这样对正数可以，但是对负数不行，因为右移是算数右移，一直在补1。所以我们可以左移1，然后不断&x。还有一种牛逼写法，就是让x&(x-1)，x-1相当于把x中最右边的1，及其右边的数取反。

相关题目：
1. 用一句话判断一个整数是不是2的整数次方，是的话那就只有1个1，x&(x-1)之后就应该为0
2. 给两个整数m和n，计算需要改变m的二进制表示中多少位才能得到n，直接异或，然后求1的个数。