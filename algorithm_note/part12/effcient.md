这一章介绍如何优化时间和空间效率。

## 1. 时间效率

除了少部分嵌入式开发，一般情况下运行内存充足，算法的时间效率比空间效率更为重要。面试时经常会考察应聘者是否能够不断优化时间效率。

那么如何优化时间效率呢？
1. 对于复杂数据结构，多采用引用或指针传递
2. 对于拼接字符串，不要用string的`+`运算符，因为会产生临时变量，应该用`append`或者`+=`，这两种操作直接在原string上拼接。
3. 判断偶数的时候，可以不用`x%2==0`，用`x&1==0`
4. 在递归的过程中，如果存在重叠子问题，可以考虑使用备忘录算法或者自底向上动规。
5. 选择合适的数据结构。

在面试过程中，我们要积极思考，展现出优化效率的激情。

面试题：
1. offer39 数组中出现次数超过一半的数字：假设数组中元素个数为$n$，那么出现次数超过一半就是出现次数要大于$\lfloor n/2 \rfloor$，这个问题也叫找众数。

    第一种思路是将问题转化为找数组第$k$大问题，假设答案存在，将数组排序后，位于数组中间的数，也就是第$\lfloor n/2 \rfloor$大的数，一定就是答案。解决第$k$大问题有很成熟的方法，就是用快排的划分，平均时间复杂度为$O(n)$，最坏的时间复杂度是$O(n^2)$。最后我们再检查一遍是答案是否真的存在。

    第二种思路是投票算法，每次维护一个候选总数，当遍历到下一个数字，如果数字等于候选众数，则次数+1，否则次数-1。如果次数为0，那么我们就保存下一个数字为候选众数。这样不断执行，最后一个候选众数就是真的众数。上述方法的真确性是机遇数组真有众数的假设，所以最后还要检查一遍。时间复杂度为$O(n)$

2. offer40 最小的k个数：同样可以通过partition，找第k小解决，时间复杂度为$O(n)$。另外一种方法是维护一个最大堆，一直维护当前数组中的最小的k个数，这种方法的时间复杂度为$O(n\log n)$，虽然时间复杂度大一点，但是这个方法有两个好处，一个是不用修改原数组，另一个是可以处理海量数组（内存放不下数组）。
3. offer41 数据流中的中位数：维护一个最大堆装数据流最小的$\lfloor k/2 \rfloor$个数字，维护一个最小堆装数据流最大的$\lceil k/2 \rceil$个数字，这样插入只需要$O(\log n)$的时间，求中位数只需要$O(1)$的时间。
4. offer42 连续子数组的最大和：经典动态规划。
5. offer43 1～n整数中1出现的次数：很牛逼的减治递归思路，每次都去除一个最高位，时间复杂度为$O(\log n)$
6. offer44 数字序列中某一位的数字：通过计算所有1位数，2位数...占有多少位，如果n大于前k位数占有位的总和，小于前k+1位数占有位的综合，那么第n位数一定出自一个k+1位数。然后用$O(1)$的时间计算出来第n位是什么就可以了。
7. offer45 把数组排成最小的数：这道题最朴素的做法就是求所有数的全排列，然后取最小，这样做的时间复杂度为$O(n!)$。一种更好的思路是找到一种合理的排序方式，然后数组根据这个排序方式排序以后，拼在一起就是最小。排序方式为：对于两个数`m`和`n`，当`mn<nm`时，我们定义`m<n`。具体证明略。PS：这道题leetcode没有收录。
8. offer46 把数字翻译成字符串：动态规划，令dp[i]表示下标`i`为止的字符串，共有多少种翻译方法，转台转移方程为`dp[i]=dp[i-1]+g(i-1,i)*dp[i-2]`，当下标为`i-1`和`i`的两个数字拼起来的数字在`10~25`的范围，`g(i-1,i)`为1，否则为0。可以使用滚动数组。
9. offer47 礼物的最大价值：经典动态规划，可以用滚动数组。
10. offer48 最长不含重复字符的子字符串：动态规划，`dp[i]`记录以下标`i`的字符为结尾的最长不重复子串的长度。状态转移：如果下标`i`的字符以前没有出现过，那么`dp[i]=dp[i-1]+1`，如果出现过，但是出现的位置`k`超过了`dp[i-1]的范围`，那么不影响，`dp[i]=dp[i-1]+1`，否则`dp[i]=i-k`。也可以理解为双指针思想。

## 2. 时间效率和空间效率的平衡
大多数面试，我们应该尝试以少量辅助空间来换取时间效率的大大提升，当然最重要的也是要多与面试官沟通，确定面试官的想考察的。

面试题：
1. offer49 丑数：关键要理解任意一个丑数乘2，3，5都还是一个丑数这个递归思想，然后逻辑上维护三个队列就行了，因为要保存丑数数组，所以是一种空间换时间的方式。
2. offer50 第一个只出现一次的字符：朴素方法是，从左到右遍历每一个字符，然后扫描字符串看它出现的次数，第一个次数为1的字符就是答案，这样的时间复杂度为$O(n^2)$，可以用哈希表存储字符出现的次数，然后从左到右扫描字符串。这样时间复杂度为$O(n)$，空间复杂度也为$O(n)$，是一种空间换时间的方法。
3. offer51 数组中的逆序对：暴力的时间复杂度是$O(n^2)$，空间复杂度为$O(1)$。使用分治，借着归并排序的模版，时间复杂度是$O(n\loh n)$，空间复杂度为$O(n)$。学到一个归并排序新思路，不要在递归函数中重复分配释放内存，而是一开始就分配一块大内存`tmp`。
4. offer52 两个链表中的第一个公共节点：假设两个链表的长度分别为$m$和$n$。使用暴力法的时间复杂度为$O(mn)$，空间复杂度为$O(1)$。如果用空间换时间，一种思路是用两个栈把链表存起来，这样就可以从尾到头反向遍历，最后一个相同的结点就是第一个公共结点。如果可以修改链表，也可以单独开辟一个域，先遍历一个链表全部打上标记，然后再遍历另外一个链表，第一个打上标记的就是第一个公共节点，还有一种思路是直接使用哈希表，这三种方法的时间复杂度都为$O(m+n)$，空间复杂度也为$O(m+n)$。还有另外一种思路，采用双指针，非常巧妙，可以吧空间复杂度降低到$O(1)$。
