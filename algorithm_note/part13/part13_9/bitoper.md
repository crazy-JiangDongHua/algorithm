这一章是关于位操作的练习。

这里详细说明一下C/C++语言中如何处理无符号数和有符号数的移位运算，以32位无符号数`unsigned int`和32位有符号数`int`为例：

1. 对于`unsigned int`和`int`，移位运算的位数都不能大于等于32，否则会触发未定义行为。
2. 对于`unsigned int`和非负值`int`，左移补零，左移k位等于乘 $2^k$  ，`unsigned int`移位超出表示范围会对$ 2^{32}$ 求模，而非负值`int`移位超出表示范围会触发未定义行为。
3. 对于负值`int`，左移会触发未定义行为，这是历史原因导致的。对于补码表示的负数，左移k位等于乘 $2^k$  ，但是在一些比较老的机器上，负数用反码和原码表示，左移k位的行为与补码不同，C/C++为了兼容老机器，所以对于负值左移操作未定义。
4. 对于`unsigned int`和非负值`int`，右移补零，右移k位等于整除 $2^k$  。
5. 对于负值`int`，右移是根据具体机器和编译器实现定义的，在我的机器上负值`int`又移定义为补码右移。

1. 面试题05.01 插入：分三步，首先将N中从j到i之间的位清零，然后对M执行以为操作与j到i之间对其，然后合并，就是或运算。
2. 面试题05.02 二进制数转字符串：通过乘2不断右移小数点，如果大于等于1则说明该位为1，否则为0。
3. 面试题05.03 翻转数位：简单模拟，不断记录之前的1 bit序列长度，注意边界条件-1会多算1位。
4. 面试题05.04 下一个数：第一反应是蛮力法，不停加一减一得到第一个1的个数相同的数。但是这么解太无趣了，当然要发现规律用位运算啦。对于求获取后一个较大的数，首先可以发现的是，如果将第i位从0翻转位1，第j位从1翻转为0，且i>j那么数将变大，所以算法可以分为三步：1.找到第一个右边存在1的0，假设它是第p位，它的后面有c1个1和c0个0；2.将第p位从0翻转位1；3.将后置c0+c1=p位全部置0；4.将拖尾的c1-1个0置1。获取前一个较小的数思路差不多。需要注意两种算法都存在无解的情况，如果输入为（11...1100...00）或者（111..111）或者（000...000），那么它没有后一个较大的数（1 bit数量相同）；如果输入为（000..00111..111）或者（111..111）或者（000...000），那么他没有前一个较小的数（1 bit数量相同）。
5. 面试题05.05 调试：`n&(n-1)`表示将n中最低位的1置0，`(n&(n-1))==0`表示n只有一位为1，所以是检查n是否为2的幂。
6. 面试题05.06 整数转换：先异或，然后判断有多少个1 bit。
7. 面试题05.07 配对交换：用(1010...1010)提取奇数位，然后右移一位。用(0101...0101)提取偶数位，然后左移一位，最后取或运算或者求和。
8. 面试题05.08 绘制直线：简单模拟，注意x1和x2是同一个byte的边界情况。