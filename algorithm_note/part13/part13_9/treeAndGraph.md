这一章是关于树与图的练习。

1. 面试题04.01 节点间通路：深度优先搜索和广度优先搜索的直接应用。
2. 面试题04.02 最小高度数：实现高度最小就应该让左右子树的节点尽可能相等，可以用递归实现。
3. 面试题04.03 特定深度节点链表：深度优先搜索和广度优先搜索的直接应用。
4. 面试题04.04 检查平衡性：经典题，自底向上递归，关键在于使用负数传递是否平衡信息。
5. 面试题04.05 合法二叉搜索树：不难但是挺有意思的一道题。一种方法是采用中序遍历，然后比较序列是否是升序排列的，但是我们并不需要把所有的元素都保存起来，只需要保存上一个元素就可以了。但是这种方法有一个问题，就是无法处理重复值，`[1,1]`和`[1,nullptr,1]`分别是有效和无效的二叉搜索数，但是中序遍历是一样的。另一种方法是利用二叉搜索树的定义，所有左边的节点都必须小于等于当前节点，而当前节点必须小于右边的节点，然后可以给出节点应该处于的范围，用递归实现。当然在leetcode的测试用例中，保持了左边的节点都必须小于当前节点，而当前节点必须小于右边的节点的定义，这点可以在面试时与面试官沟通。
6. 面试题04.06 后继者：经典题。但是leetcode给的接口很新颖，当`TreeNode`没有`parent`这个成员变量时，对于右子树为空的情况，没法直接沿着父节点路径搜索第一个把`p`囊阔在左子树的祖先。那么可以从根节点开始搜索，如果根节点大于p，那么说明p的后继节点是根节点或者在根节点的左子树中，如果根节点小于p，那么p的后继节点在根结点的右子树中。当访问到根节点是，直接转入右子树退出循环。
7. 面试题04.07 编译顺序：拓扑排序的直接应用，用dfs或者不停找入度为0的点。这题leetcode没有收录
8. 面试题04.08 首个共同祖先：如果`TreeNode`有`parent`这个成员变量时，那就是求两个链表的第一个相交节点，如果不用栈的话，这样时间复杂度为$O(2d)$，d是更深的节点深度，最坏为$O(2n)$。所以还有另外一个更好的方法，就是从一个节点开始，不停的检查其兄弟节点是否包括另外一个节点，如果包括，那么它的父节点就是答案，这样最坏时间复杂度是$O(n)$，但是普通情况下就变慢了；如果是二叉搜索树，就是递归的搜索第一个处于二者之间的节点；如果都不是，也可以递归的搜索第一个处于二者之间的节点，但是判断节点处于哪个子树就只能爆搜，虽然时间复杂度还是$O(n)$，但是还是有很多重复操作。因此可以爆搜两个节点到根节点的路径，这又转换成了两个链表的最后一个相交节点。但是这题不允许把节点存储到另外的数据结构中，所以只能通过递归向上“冒泡”，需要注意的是，向上递归无法区分一个节点不在树中和一个节点在另一个节点的子树中，因此需要设置一个额外的成员变量（bool型）来区分。leetcode给出了更精简的写法。但是如果深究鲁棒性的话，三种实现都没有考虑`p==q`的情况和`p==nullptr`或者`q==nullptr`，更鲁棒的写法应该用`vector`把路径存下来。
9. 面试题04.09 二叉搜索树序列：根节点必须被首先插入，然后递归求左右子树的插入序列，左右子树节点之间的插入顺序无所谓，只需要保证单个子树节点之间的顺序就行，也需要通过递归实现交织。另有一个大佬写了一个回溯方法，每次用一个双头队列维护一个候选队列，然后求候选队列的类似全排列即可。
10. 面试题04.10 检查子树：一种方法是搜索较大的树T1，每次T1有一个节点与T2一个节点匹配的时候，就用treeMatch来比较两个子树，时间复杂度是 $O(n+km)$ ，k是T2根节点在T1中出现的次数，空间复杂度为树的最大高度。另一种方法是比较T2的先序遍历是不是T1的先序遍历的子串，注意需要特殊表示空节点，这样才能保证先序遍历唯一，检测子串的方法可以是KMP算法，所以时间复杂度$O(m+n)$，空间复杂度$O(m+n)$。
11. 面试题04.11 随机节点：让每个节点记录以其为根节点的子树的节点数目，然后通过在0～n中间随机取一个i，表示取中序遍历序列的第i个点，然后递归寻找就可以了。
12. 面试题04.12 求和路径：一种简单的思想就是以每一个节点作为根节点，搜索其子树中的满足条件的路径。这样做使得每个深度为d的节点，都要被访问d次，如果是BST,时间复杂度是$O(n\log n)$，空间复杂度为$O(\log n)$，如果是普通二叉树，时间复杂度是 $n^2$ ，空间复杂度是 $\log n$。但是这样做会存大大量的重复计算，我们可以使用dfs，然后用哈希表记录这条路径上已经存在的和，如果存在当前和减去目标值的和，那么就发现了可行解。这样每个节点只需要被访问一次，时间复杂度是$O(n)$，空间复杂度相同。