这一章是关于链表的习题。

1. 面试题02.01 移除重复节点：一种是用hash表，时间和空间复杂度都为 $O(n)$ ，一种是对每一个节点，都遍历剩余节点，如果重复就删除，时间复杂度 $O(n^2)$ ，空间复杂度 $O(n)$ 。
2. 面试题02.02 返回倒数第k个节点：经典题，注意错误输入。
3. 面试题02.03 删除中间节点：把后面一个结点的值复制到当前节点，然后删除后面一个节点就好了，因为不是最后一个节点所以没关系。二叉搜索树的删除也有同样的技巧。
4. 面试题02.04 分割链表：一种直观的想法是设置before和after两个链表，遍历原链表，小的放before，大于等于的放after，然后合并链表，这样可以保证链表元素的相对位置，但是需要四个变量。如果不需要保证元素的相对位置，那么可以只维护一个链表，小的插入链表头部，大于等于的插入链表尾部，这样只需要两个变量。
5. 面试题02.05 链表求和：大数求和链表版。如果数位是正向排列的，一种方法是反转链表然后用本题算法求解之后再反转链表，这样时间复杂度常系数乘4。一种是用递归隐式地从低位算起，这样需要首先给短的链表前面填0，这样时间复杂度乘3，但是递归所需要的空间复杂度为 $O(n)$ 。
6. 面试题02.06 链表回文；第一种是反转链表，然后比较反转后的链表和原链表是否一样就可以了，同时可以优化到比较一半就行了。第二种是用栈存储链表的前半部分，然后依次弹出和后半部分相比，找到链表的终点就用快慢指针就行了。
7. 面试题02.07 链表相交：经典题目。如果可以改变链表元素，那就先遍历一条链表打标记，再遍历另外一条链表；如果不可以打标记，一种使用两个栈把链表存起来，然后找第一个分叉点；一种是遍历链表，到头的时候跳转到另一个链表头，这样最终会在第一个相同节点相遇（可以是nullptr），这种方法看起来玄妙，其实等价于先得到链表长度，然后长的先走几步，然后再比较，有个优化是如果尾节点不同，那一定没有相交点。
8. 面试题02.08 环路检测：经典问题。