1. 最大连续子序列和
寻找连续子序列都可以通过枚举左右端点，时间复杂度为$O(n^2)$，求和的话可以通过预处理计算前缀和，让时间复杂度降为$O(1)$。但是采用动态规划的话，我们发现其实可以不用枚举左端点。
```c++
int arr[maxn], n;
int dp[maxn] = {0};

int maxsubsum()
{
    dp[0]=arr[0];
    for(int i=1;i<n;i++)
    {
        dp[i] = dp[i-1]>0 ? dp[i-1]+arr[i] : arr[i];
    }
    int k = -1;
    for(int i=0;i<n;i++)
    {
        if(dp[i] > dp[k])
            k = i;
    }
    return dp[k];
}
```

2. 最长不降子序列
直接枚举不连续子序列需要$O(2^n)$的时间复杂度。采用动态规划的时间复杂度为$O(n^2)$
```c++
int arr[maxn], n;
int dp[maxn] = {0}; //dp[i]表示以arr[i]为结尾的最长不降子序列长度
int maxsubsum()
{
    for(int i=0;i<n;i++)
    {
        dp[i] = 1;
        for(int j=0;j<i;j++)
        {
            if(arr[j]<=arr[i])
            	dp[i] = dp[j]+1>dp[i] ? dp[j]+1 : dp[i];
        }
    }
    int k = -1;
    for(int i=0;i<n;i++)
    {
        if(dp[i] > dp[k])
            k = i;
    }
    return dp[k];
}
```

3. 最长公共子序列
```c++
char a[maxm], b[maxn], m, n;
int dp[maxm+1][maxn+1]={0};// 递归边界，dp[0][]=dp[][0]=0
int lcs()
{
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            if(a[i] == b[j])
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    return dp[m][n];
}
```
与之相对的是最长连续公共子序列，他们两者的dp数组的含义和递推方程，以及最后的求解方式都不一样。

* 最长公共子序列
    * `dp[i][j]`表示`a`的前`i`个字符和`b`的前`i`个字符的最长公共子序列长度
    * 递推方程如上代码所述
    * 最终答案就是`dp[m][n]`
* 最长连续公共子序列
    * `dp[i][j]`表示以`a`的第`i`个字符和`b`的第`j`个字符为结尾的最长连续公共子序列长度，这个定义和最长连续子段和有点类似。
    * 递推方程与最长公共子序列问题不同时，当`a[i]!=b[j]`，那么`dp[i][j]=0`
    * 最后答案需要遍历dp矩阵，寻找最大值。

4. 最长回文子串

```c++
char a[maxn], n;
int dp[maxn][maxn]={0};//dp[i][j]表示i-j是不是回文，0不是，1是

int lsr()
{
    int ans = 1;
    for(int i=0;i<n;i++)
    {
        dp[i][i] = 1;
    }
    for(int i=0;i<n-1;i++)
    {
        dp[i][i+1] = a[i] == a[j]?ans=2,1:0;
    }
    for(int len=3;len<=n;len++)
        for(int i=0;i+len-1<n;i++)
        {
            if(arr[i] == arr[i+len-1] && dp[i+1][i+len-2])
            {
                dp[i][i+len-1] = 1;
                a = len;
            }
            else
                dp[i][j] = 0;
        }
    return ans;
}
```

最长回文子串还有一种更好的算法，叫马拉车算法，只需要O(n)的时间复杂度。

5. 背包问题

```c++
//01背包
//dp[i][v]前i件物品放入v重的包
//dp[i][v] = max(dp[i-1][v], dp[i-1][v-w[i]]+c[i])
//边界：dp[i][0]=0,dp[0][i]=0;
//可以使用滚动数组，j从大到小迭代

//完全背包
//dp[i][v] = max(dp[i-1][v], dp[i][v-w[i]]+c[i])
//可以使用滚动数组，j从小到大迭代
```

练习：
1. leetcode 5 最长回文子串：马拉车算法，`p[i]`表示半径，包括中心点，`p[i]-1`表示回文串长度，`(i-p[i])/2`表示回文串在原字符串起始位置。
2. leetcode 120 三角形的最小路径和：自底向上dp，`dp[i][j]`表示从`trangle[i][j]`一直走到底层的最小花费。可以空间优化至$O(n)$
3. leetcode 53 最大子数组和：就是最大连续子段和，可以把空间优化到$O(1)$，也可以分治，分为左右两个数组，归并时，要么是左边数组的最大子段和，要么是右边的最大子段和，要么是连接连个子数组，从中间拓展的的最大子段和，时间复杂度为$O(n\log n)$
4. interview 17.24 最大矩阵和：这个可以利用最大子段和的思想，枚举矩阵的起始行和终止行，然后将矩阵压缩，即按列求和，这样就变成了最大子段和，总的时间复杂度是$O(m^2n)$。如果行比列小，也可以枚举起始列和终止列，然后按行求和。
5. 51nod 1052 最大m子段和：取数组的m个不相交子段，使其和最大。设置`dp[i][j]`表示前`j`个元素，取`i`段，第`j`个元素一定属于最后一个段。状态转移：对于第`j`个元素，可以把他作为单独一段，那么`dp[i][j]=max(dp[i-1][k])+arr[j],i-1<=k<=j-1`,也可以直接并入最后一段，那么`dp[i][j]=dp[i][j-1]+arr[j]`。最后的结果取`dp[m][k], m<=k<=n`的最大值。如果有要求说m大于数组中正数的个数，就只输出正数的和，那就开始的时候单独判断一下。
6. leetcode 132 分割回文串2：这道题还挺有意思的，要做两个dp。首先预处理，通过dp得到s的每个子串是不是回文串。然后设置dp数组`f[]`，`f[i]`表示s从0到i的子串最少需要分割几次才能全部都是回文串。最好的就是s从0到i的子串本身就是回文串，那么不需要分割，`f[i]=0`。否则，就只能遍历`f[j], 0<=j<i`，如果s从j+1到i的子串是字符串，那么`f[i]=f[j]+1`就是`f[i]`的一个可能解，选择可能解最小的就可以了。不需要考虑无解的情况，因为`j=i-1`时，i一个字符必然是回文串，所以一定有`f[i]=f[i-1]+1`这个解。
7. leetcode 85 最大矩形：该题可以参考leetcode84的方式，看成m行不同高度的柱形能够拼成的高度，然后用单调栈计算出每个柱形的左右边界。但是本题具有特殊性，可以不用单调栈，只需要从左到右和从右到左两遍就可以得到结果，因为如果某一个位置是0，那么该位置的柱形高度直接变为0，直接变成后面所有柱形的左边界，只需要用一个变量记住最近的高度为0的柱形位置就可以了，右边界同理。
8. leetcode 121 买卖股票的最佳时机1：之前介绍了一遍遍历的方法，这次介绍一个最大子段和的方法。先求出原数组的差分数组，就后一项减去前一项，然后该数组的最大子段和与0（因为如果交易一定亏本，可以不交易）之间的最大值就是要求的值。
9. leetcode 122 买卖股票的最佳时机2：dp存在两个状态，当天结束持有股票（`dp1`）和不持有股票（`dp0`）的最大收益。状态转移`dp0=max(dp0, dp1+prices[i]);dp1=max(dp1, dp0-prices[i]);`
10. leetcode 123 买卖股票的最佳时机3：这个问题相当于leetcode188的特殊版本，把k改成2就ok。因为只交易两次，其实还有一种特别逆天的写法，可以看作是`[0,i]`号物品和`[i,n-1]`号物品，各至多交易一次，然后和的最大值。因为至多交易一次，我们可以用遍历一遍的方法求出来，所以时间复杂度为$O(n)$。
11. leetcode 188 买卖股票的最佳时机4：所有股票问题的通解。设置`buy[i][j]`和`sell[i][j]`分别表示前`i`个物品，交易`j`次（卖出后才算一次交易），能获得的最大收益，状态转移与leetcode122类似，可以做空间优化到$O(n)$，时间复杂度$O(nk)$。也可以看作是差分数组的最大m子段和，任意前i个元素分为j段的最大值就是答案，时间复杂度是$O(n(n-m))$。
12. leetcode 97 交错字符串：`dp[i][j]`表示s1前`i`个字符和s2前`j`个字符能够构成s3前`i+j`个字符。状态转移可以表示为`dp[i][j]= s1[i-1]==s3[i+j-1]&&dp[i-1][j]||s2[j-1]==s3[i+j-1]&&dp[i][j-1];`。可以通过滚动数组优化空间复杂度。
13. leetcode 87 扰乱字符串：首先可以get到，如果`s`是`t`的扰动字符串，那么`t`一定也是`s`的扰动字符串。然后可以对`s`和`t`做划分，划分出四个子串，如果子串两两互为扰动字符串，那么`s`和`t`就是互为扰动字符串。划分可以分为交换和不交换的情况，有`n-1`种划分位置。设置`dp[i][j][len]`表示`s`中从第`i`位开始的长度为`len`的子串和`t`中从第`j`位开始的长度为`len`的子串是否互为扰动，通过记忆化搜索实现。另外需要两个剪枝技巧，如果两个子串相等，那么必然互为扰动；如果两个字符串中的各个字符出现次数不同，必然不互为扰动。
14. leetcode 64 最小路径和：和leetcode 62 不同路径相似，简单dp，可以用滚动数组节省空间。
15. leetcode 72 编辑距离：过于经典，不解释了。
16. leetcode 91 解码方法：设`dp[i]`表示前i个字符的解码数量，可以由`dp[i-2]`和`dp[i-1]`转移过来，因此也可以压缩空间至3个变量。
17. leetcode 115 不同的子序列：设`dp[i][j]`表示`t`前`j`个字符在`s`前`i`个字符中出现的次数。状态转移：`dp[i][j]=dp[i-1][j]+ dp[i-1][j-1] if s[i]==t[i]) else 0`。初始化`dp[i][0]`表示空字符串出现字数，设为1。其他为0。可以用滚动数组做空间优化。
18. leetcode 139 单词拆分：和leetcode91 解码方式思路一样，只不过解的编码从"1"~"26"变成了`wordDict`里面的字符串。
19. leetcode 140 单词拆分2：和上题一样，只是记录一下。